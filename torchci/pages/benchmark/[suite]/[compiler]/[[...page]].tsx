import dayjs, { Dayjs } from "dayjs";
import ReactECharts from "echarts-for-react";
import { EChartsOption } from "echarts";
import useSWR from "swr";
import _ from "lodash";
import {
  Grid,
  Paper,
  Skeleton,
  Stack,
  Typography,
  Divider,
} from "@mui/material";
import { useRouter } from "next/router";
import {
  GridValueFormatterParams,
  GridRenderCellParams,
  GridCellParams,
} from "@mui/x-data-grid";
import React from "react";
import { useState, useEffect } from "react";
import { RocksetParam } from "lib/rockset";
import { fetcher } from "lib/GeneralUtils";
import {
  Granularity,
  TimeSeriesPanelWithData,
  seriesWithInterpolatedTimes,
} from "components/metrics/panels/TimeSeriesPanel";
import { TablePanelWithData } from "components/metrics/panels/TablePanel";
import GranularityPicker from "components/GranularityPicker";
import { TimeRangePicker } from "../../../metrics";
import {
  COMPILER_NAMES_TO_DISPLAY_NAMES,
  DTypePicker,
  DTYPES,
  BranchAndCommitPicker,
  SuitePicker,
  SUITES,
  LAST_N_DAYS,
  HUD_PREFIX,
  TIME_FIELD_NAME,
  MAIN_BRANCH,
  SPEEDUP_THRESHOLD,
  COMPILATION_lATENCY_THRESHOLD_IN_SECONDS,
  COMPRESSION_RATIO_THRESHOLD,
  PASSING_ACCURACY,
  DIFF_HEADER,
} from "../../compilers";
import { CompilerPerformanceData } from "lib/types";
import styles from "components/metrics.module.css";

const TABLE_ROW_HEIGHT = 1000;
const GRAPH_ROW_HEIGHT = 245;
const ROW_GAP = 30;

// Headers
const ACCURACY_HEADER = "Accuracy";
const SPEEDUP_HEADER = `Performance speedup (threshold = ${SPEEDUP_THRESHOLD}x)`;
const LATENCY_HEADER = `Compilation latency in seconds (threshold = ${COMPILATION_lATENCY_THRESHOLD_IN_SECONDS}s)`;
const MEMORY_HEADER = `Peak memory compression ratio (threshold = ${COMPRESSION_RATIO_THRESHOLD}x)`;

function CommitPanel({
  branch,
  commit,
  date,
}: {
  branch: string;
  commit: string;
  date: string;
}) {
  return (
    <Stack direction="row" spacing={2} sx={{ mb: 2 }}>
      <Typography fontSize={"1rem"} fontStyle={"italic"}>
        *This report was generated by CI running on PyTorch {branch} branch at{" "}
        <a href={`${HUD_PREFIX}/${commit}#inductor-a100-perf-nightly`}>
          {commit.substring(0, 7)}
        </a>{" "}
        on {dayjs(date).format("YYYY/MM/DD")}.
      </Typography>
    </Stack>
  );
}

function ModelPanel({
  suite,
  dtypes,
  compiler,
  model,
  lBranch,
  lCommit,
  lData,
  rBranch,
  rCommit,
  rData,
}: {
  suite: string;
  dtypes: string;
  compiler: string;
  model: string;
  lBranch: string;
  lCommit: string;
  lData: CompilerPerformanceData[];
  rBranch: string;
  rCommit: string;
  rData: CompilerPerformanceData[];
}) {
  const dataGroupedByModel: { [k: string]: any } = {};
  lData.forEach((record: CompilerPerformanceData) => {
    dataGroupedByModel[record.name] = {
      l: record,
    };
  });

  // Combine with right data
  if (lCommit !== rCommit) {
    rData.forEach((record: CompilerPerformanceData) => {
      if (record.name in dataGroupedByModel) {
        dataGroupedByModel[record.name]["r"] = record;
      } else {
        dataGroupedByModel[record.name] = {
          r: record,
        };
      }
    });
  }

  // Transform the data into a displayable format
  const data = Object.keys(dataGroupedByModel).map((name: string) => {
    const record = dataGroupedByModel[name];
    const hasL = "l" in record;
    const hasR = "r" in record;

    return {
      name: name,

      // Accuracy
      accuracy: {
        l: hasL ? record["l"]["accuracy"] : undefined,
        r: hasR ? record["r"]["accuracy"] : undefined,
      },

      // Speedup
      speedup: {
        l: hasL ? record["l"]["speedup"] : 0,
        r: hasR ? record["r"]["speedup"] : 0,
      },

      // Compilation latency
      compilation_latency: {
        l: hasL ? record["l"]["compilation_latency"] : 0,
        r: hasR ? record["r"]["compilation_latency"] : 0,
      },

      // Compression ratio
      compression_ratio: {
        l: hasL ? record["l"]["compression_ratio"] : 0,
        r: hasR ? record["r"]["compression_ratio"] : 0,
      },
    };
  });

  return (
    <Grid container spacing={2}>
      <Grid item xs={12} lg={12} height={TABLE_ROW_HEIGHT + ROW_GAP}>
        <TablePanelWithData
          title={"Models"}
          data={data}
          columns={[
            {
              field: "name",
              headerName: "Name",
              flex: 1,
              cellClassName: (params: GridCellParams<string>) => {
                return model !== undefined && params.value === model
                  ? styles.selectedRow
                  : styles.name;
              },
              renderCell: (params: GridRenderCellParams<string>) => {
                const name = params.value;
                if (name === undefined) {
                  return `Invalid model name ${name}`;
                }

                const encodedName = encodeURIComponent(name);
                const url = `/benchmark/${suite}/${compiler}?model=${encodedName}&dtypes=${dtypes}&lBranch=${lBranch}&lCommit=${lCommit}&rBranch=${rBranch}&rCommit=${rCommit}`;
                return <a href={url}>{name}</a>;
              },
            },
            {
              field: "accuracy",
              headerName:
                lCommit === rCommit
                  ? ACCURACY_HEADER
                  : `${ACCURACY_HEADER}: ${DIFF_HEADER}`,
              flex: 1,
              cellClassName: (params: GridCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                if (lCommit === rCommit) {
                  return PASSING_ACCURACY.includes(v.l) ? "" : styles.warning;
                } else {
                  if (
                    PASSING_ACCURACY.includes(v.l) &&
                    !PASSING_ACCURACY.includes(v.r)
                  ) {
                    return styles.ok;
                  }

                  if (
                    !PASSING_ACCURACY.includes(v.l) &&
                    PASSING_ACCURACY.includes(v.r)
                  ) {
                    return styles.error;
                  }

                  if (
                    !PASSING_ACCURACY.includes(v.l) &&
                    !PASSING_ACCURACY.includes(v.r)
                  ) {
                    return styles.warning;
                  }
                }

                return "";
              },
              renderCell: (params: GridRenderCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                if (lCommit === rCommit) {
                  return v.l;
                } else {
                  return `${v.l} ← ${v.r}`;
                }
              },
            },
            {
              field: "speedup",
              headerName: SPEEDUP_HEADER,
              flex: 1,
              cellClassName: (params: GridCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                const l = Number(v.l);
                const r = Number(v.r);

                if (lCommit === rCommit) {
                  return l >= SPEEDUP_THRESHOLD ? "" : styles.warning;
                } else {
                  if (l >= SPEEDUP_THRESHOLD && r < SPEEDUP_THRESHOLD) {
                    return styles.ok;
                  }

                  if (l < SPEEDUP_THRESHOLD && r >= SPEEDUP_THRESHOLD) {
                    return styles.error;
                  }

                  if (l < SPEEDUP_THRESHOLD && r < SPEEDUP_THRESHOLD) {
                    return styles.warning;
                  }
                }

                return "";
              },
              renderCell: (params: GridRenderCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                const l = Number(v.l).toFixed(2);
                const r = Number(v.r).toFixed(2);

                if (lCommit === rCommit) {
                  return l;
                } else {
                  return `${l} ← ${r} ${
                    Number(l) < Number(r) ? "\uD83D\uDD3B" : ""
                  }`;
                }
              },
            },
            {
              field: "compilation_latency",
              headerName: LATENCY_HEADER,
              flex: 1,
              cellClassName: (params: GridCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                const l = Number(v.l);
                const r = Number(v.r);

                if (lCommit === rCommit) {
                  return l > COMPILATION_lATENCY_THRESHOLD_IN_SECONDS
                    ? styles.warning
                    : "";
                } else {
                  if (
                    l <= COMPILATION_lATENCY_THRESHOLD_IN_SECONDS &&
                    r > COMPILATION_lATENCY_THRESHOLD_IN_SECONDS
                  ) {
                    return styles.ok;
                  }

                  if (
                    l > COMPILATION_lATENCY_THRESHOLD_IN_SECONDS &&
                    r <= COMPILATION_lATENCY_THRESHOLD_IN_SECONDS
                  ) {
                    return styles.error;
                  }

                  if (
                    l > COMPILATION_lATENCY_THRESHOLD_IN_SECONDS &&
                    r > COMPILATION_lATENCY_THRESHOLD_IN_SECONDS
                  ) {
                    return styles.warning;
                  }
                }

                return "";
              },
              renderCell: (params: GridRenderCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                const l = Number(v.l).toFixed(0);
                const r = Number(v.r).toFixed(0);

                if (lCommit === rCommit) {
                  return l;
                } else {
                  return `${l} ← ${r} ${
                    Number(l) > Number(r) && Number(r) != 0
                      ? "\uD83D\uDD3A"
                      : ""
                  }`;
                }
              },
            },
            {
              field: "compression_ratio",
              headerName: MEMORY_HEADER,
              flex: 1,
              cellClassName: (params: GridCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                const l = Number(v.l);
                const r = Number(v.r);

                if (lCommit === rCommit) {
                  return l >= COMPRESSION_RATIO_THRESHOLD ? "" : styles.warning;
                } else {
                  if (
                    l >= COMPRESSION_RATIO_THRESHOLD &&
                    r < COMPRESSION_RATIO_THRESHOLD
                  ) {
                    return styles.ok;
                  }

                  if (
                    l < COMPRESSION_RATIO_THRESHOLD &&
                    r >= COMPRESSION_RATIO_THRESHOLD
                  ) {
                    return styles.error;
                  }

                  if (
                    l < COMPRESSION_RATIO_THRESHOLD &&
                    r < COMPRESSION_RATIO_THRESHOLD
                  ) {
                    return styles.warning;
                  }
                }

                return "";
              },
              renderCell: (params: GridRenderCellParams<any>) => {
                const v = params.value;
                if (v === undefined) {
                  return "";
                }

                const l = Number(v.l).toFixed(2);
                const r = Number(v.r).toFixed(2);

                if (lCommit === rCommit) {
                  return l;
                } else {
                  return `${l} ← ${r} ${
                    Number(l) < Number(r) ? "\uD83D\uDD3B" : ""
                  }`;
                }
              },
            },
          ]}
          dataGridProps={{ getRowId: (el: any) => el.name }}
        />
      </Grid>
    </Grid>
  );
}

function GraphPanel({
  queryParams,
  granularity,
  suite,
  compiler,
  model,
  branch,
}: {
  queryParams: RocksetParam[];
  granularity: Granularity;
  suite: string;
  compiler: string;
  model: string;
  branch: string;
}) {
  const queryCollection = "inductor";
  const queryName = "compilers_benchmark_performance";

  const queryParamsWithBranch: RocksetParam[] = [
    {
      name: "branch",
      type: "string",
      value: branch,
    },
    ...queryParams,
  ];
  const url = `/api/query/${queryCollection}/${queryName}?parameters=${encodeURIComponent(
    JSON.stringify(queryParamsWithBranch)
  )}`;

  const { data, error } = useSWR(url, fetcher, {
    refreshInterval: 60 * 60 * 1000, // refresh every hour
  });

  if (data === undefined || data.length === 0) {
    return <Skeleton variant={"rectangular"} height={"100%"} />;
  }

  if (model === undefined) {
    return <></>;
  }

  // Clamp to the nearest granularity (e.g. nearest hour) so that the times will
  // align with the data we get from Rockset
  const startTime = dayjs(
    queryParams.find((p) => p.name === "startTime")?.value
  ).startOf(granularity);
  const stopTime = dayjs(
    queryParams.find((p) => p.name === "stopTime")?.value
  ).startOf(granularity);

  const groupByFieldName = "name";
  const chartData = data.filter(
    (record: CompilerPerformanceData) => record.name == model
  );

  const geomeanSeries = seriesWithInterpolatedTimes(
    chartData,
    startTime,
    stopTime,
    granularity,
    groupByFieldName,
    TIME_FIELD_NAME,
    "speedup",
    false
  );
  const compTimeSeries = seriesWithInterpolatedTimes(
    chartData,
    startTime,
    stopTime,
    granularity,
    groupByFieldName,
    TIME_FIELD_NAME,
    "compilation_latency",
    false
  );
  const memorySeries = seriesWithInterpolatedTimes(
    chartData,
    startTime,
    stopTime,
    granularity,
    groupByFieldName,
    TIME_FIELD_NAME,
    "compression_ratio",
    false
  );

  return (
    <Grid container spacing={2}>
      <Grid item xs={12} lg={4} height={GRAPH_ROW_HEIGHT}>
        <TimeSeriesPanelWithData
          data={chartData}
          series={geomeanSeries}
          title={`Geomean`}
          groupByFieldName={groupByFieldName}
          yAxisRenderer={(unit) => {
            return `${unit}`;
          }}
          additionalOptions={{
            yAxis: {
              scale: true,
            },
          }}
        />
      </Grid>

      <Grid item xs={12} lg={4} height={GRAPH_ROW_HEIGHT}>
        <TimeSeriesPanelWithData
          data={chartData}
          series={compTimeSeries}
          title={`Mean compilation time`}
          groupByFieldName={groupByFieldName}
          yAxisLabel={"second"}
          yAxisRenderer={(unit) => {
            return `${unit}`;
          }}
          additionalOptions={{
            yAxis: {
              scale: true,
            },
          }}
        />
      </Grid>

      <Grid item xs={12} lg={4} height={GRAPH_ROW_HEIGHT}>
        <TimeSeriesPanelWithData
          data={chartData}
          series={memorySeries}
          title={`Peak memory footprint compression ratio`}
          groupByFieldName={groupByFieldName}
          yAxisRenderer={(unit) => {
            return `${unit}`;
          }}
          additionalOptions={{
            yAxis: {
              scale: true,
            },
          }}
        />
      </Grid>
    </Grid>
  );
}

function Report({
  queryParams,
  granularity,
  suite,
  dtypes,
  compiler,
  model,
  lBranch,
  lCommit,
  rBranch,
  rCommit,
}: {
  queryParams: RocksetParam[];
  granularity: Granularity;
  suite: string;
  dtypes: string;
  compiler: string;
  model: string;
  lBranch: string;
  lCommit: string;
  rBranch: string;
  rCommit: string;
}) {
  const queryCollection = "inductor";
  const queryName = "compilers_benchmark_performance";

  const queryParamsWithL: RocksetParam[] = [
    {
      name: "branch",
      type: "string",
      value: lBranch,
    },
    {
      name: "commits",
      type: "string",
      value: lCommit,
    },
    ...queryParams,
  ];
  const lUrl = `/api/query/${queryCollection}/${queryName}?parameters=${encodeURIComponent(
    JSON.stringify(queryParamsWithL)
  )}`;

  const { data: lData, error: lError } = useSWR(lUrl, fetcher, {
    refreshInterval: 60 * 60 * 1000, // refresh every hour
  });

  const queryParamsWithR: RocksetParam[] = [
    {
      name: "branch",
      type: "string",
      value: rBranch,
    },
    {
      name: "commits",
      type: "string",
      value: rCommit,
    },
    ...queryParams,
  ];
  const rUrl = `/api/query/${queryCollection}/${queryName}?parameters=${encodeURIComponent(
    JSON.stringify(queryParamsWithR)
  )}`;

  const { data: rData, error: rError } = useSWR(rUrl, fetcher, {
    refreshInterval: 60 * 60 * 1000, // refresh every hour
  });

  if (
    lData === undefined ||
    lData.length === 0 ||
    rData === undefined ||
    rData.length === 0
  ) {
    return <Skeleton variant={"rectangular"} height={"100%"} />;
  }

  return (
    <div>
      <CommitPanel
        branch={lBranch}
        commit={lCommit}
        date={lData[0].granularity_bucket}
      />
      <GraphPanel
        queryParams={queryParams}
        granularity={granularity}
        suite={suite}
        compiler={compiler}
        model={model}
        branch={lBranch}
      />
      <ModelPanel
        suite={suite}
        dtypes={dtypes}
        compiler={compiler}
        model={model}
        lBranch={lBranch}
        lCommit={lCommit}
        lData={lData}
        rBranch={rBranch}
        rCommit={rCommit}
        rData={rData}
      />
    </div>
  );
}

export default function Page() {
  const router = useRouter();

  // The dimensions to query Rockset
  const compiler: string = (router.query.compiler as string) ?? undefined;
  const model: string = (router.query.model as string) ?? undefined;

  const [startTime, setStartTime] = useState(
    dayjs().subtract(LAST_N_DAYS, "day")
  );
  const [stopTime, setStopTime] = useState(dayjs());
  const [granularity, setGranularity] = useState<Granularity>("hour");
  const [dtypes, setDTypes] = useState<string>(DTYPES[0]);
  const [suite, setSuite] = useState<string>(Object.keys(SUITES)[0]);
  const [lBranch, setLBranch] = useState<string>(MAIN_BRANCH);
  const [lCommit, setLCommit] = useState<string>("");
  const [rBranch, setRBranch] = useState<string>(MAIN_BRANCH);
  const [rCommit, setRCommit] = useState<string>("");

  // Set the dropdown value what is in the param
  useEffect(() => {
    const dtypes: string = (router.query.dtypes as string) ?? undefined;
    if (dtypes !== undefined) {
      setDTypes(dtypes);
    }

    const suite: string = (router.query.suite as string) ?? undefined;
    if (suite !== undefined) {
      setSuite(suite);
    }

    const lBranch: string = (router.query.lBranch as string) ?? undefined;
    if (lBranch !== undefined) {
      setLBranch(lBranch);
    }

    const lCommit: string = (router.query.lCommit as string) ?? undefined;
    if (lCommit !== undefined) {
      setLCommit(lCommit);
    }

    const rBranch: string = (router.query.rBranch as string) ?? undefined;
    if (rBranch !== undefined) {
      setRBranch(rBranch);
    }

    const rCommit: string = (router.query.rCommit as string) ?? undefined;
    if (rCommit !== undefined) {
      setRCommit(rCommit);
    }
  }, [router.query]);

  if (suite === undefined || compiler === undefined) {
    return <Skeleton variant={"rectangular"} height={"100%"} />;
  }

  const queryParams: RocksetParam[] = [
    {
      name: "timezone",
      type: "string",
      value: Intl.DateTimeFormat().resolvedOptions().timeZone,
    },
    {
      name: "startTime",
      type: "string",
      value: startTime,
    },
    {
      name: "stopTime",
      type: "string",
      value: stopTime,
    },
    {
      name: "granularity",
      type: "string",
      value: granularity,
    },
    {
      name: "suites",
      type: "string",
      value: suite,
    },
    {
      name: "compilers",
      type: "string",
      value: compiler,
    },
    {
      name: "dtypes",
      type: "string",
      value: dtypes,
    },
  ];

  return (
    <div>
      <Stack direction="row" spacing={2} sx={{ mb: 2 }}>
        <Typography fontSize={"2rem"} fontWeight={"bold"}>
          TorchInductor Performance DashBoard (
          {COMPILER_NAMES_TO_DISPLAY_NAMES[compiler] || compiler})
        </Typography>
        <TimeRangePicker
          startTime={startTime}
          stopTime={stopTime}
          setStartTime={setStartTime}
          setStopTime={setStopTime}
          defaultValue={LAST_N_DAYS}
        />
        <GranularityPicker
          granularity={granularity}
          setGranularity={setGranularity}
        />
        <SuitePicker suite={suite} setSuite={setSuite} />
        <DTypePicker dtypes={dtypes} setDTypes={setDTypes} />
        <BranchAndCommitPicker
          branch={lBranch}
          setBranch={setLBranch}
          commit={lCommit}
          setCommit={setLCommit}
          queryParams={queryParams}
        />
        <Divider orientation="vertical" flexItem>
          Diff
        </Divider>
        <BranchAndCommitPicker
          branch={rBranch}
          setBranch={setRBranch}
          commit={rCommit}
          setCommit={setRCommit}
          queryParams={queryParams}
        />
      </Stack>

      <Grid item xs={12}>
        <Report
          queryParams={queryParams}
          granularity={granularity}
          suite={suite}
          dtypes={dtypes}
          compiler={compiler}
          model={model}
          lBranch={lBranch}
          lCommit={lCommit}
          rBranch={rBranch}
          rCommit={rCommit}
        />
      </Grid>
    </div>
  );
}
